# CORE (ORACLE架构)
## ORACLE 三个部分
1. 进程：用户进程，服务器进程
2. 实例：内存、守护进程，运行在服务器上。
3. 数据库:保证数据不会丢,由数据文件组成,以块为单位。

- 用户登录，登录的是实例，访问的是内存，不是直接访问数据库文件；
- 实例里的进程负责读取数据库到内存(共享内存)；用户不能直接操作内存中的数据，怕被写坏了，有个服务器进程对内存操作。产生一个用户进程，就一对一产生一个服务器进程；
- 守护进程
- 内存坏了没事，有守护进程，运维要保护好数据文件。
- 数据库的据文件：数据文件（用户数据），控制文件（管理数据），重做日志文件（用户数据物理改变信息）,警告日志文件ALERTLOG，密码文件（超级数据库管理员）

> update动作:拷贝原来的行数据，拷贝数据的物理位置，生成REDOLOG（记载在内存REDOLOG BUFFER，commit后由进程LGWR操作写道REDOLOG），update后就改成功了，commit后才写入rudolog数据文件，没有写入数据文件，最后由DBWR异步写入数据文件。(若commit后当机，重启后按RUDOLOG重写数据文件，通过CKPT，通知DBWR写，有时DBWR的时候若发现要写的数据还在BUFFER，就通知LGWR先写REDULOG)

- 重做日志文件：分组，每组文件相同；至少两个组；循环、切换写，有可能覆盖，所以配置成归档日志，切换前先拷贝被切换的日志组到归档日志
-	五个进程必须，运维需查看。(归档日志进程不是必须)
	* PMON:异常用户进程断开，回收资源：服务器进程、内存，回滚事务。
	* SMON:作REDULOG恢复，
	* DBWR
	* LGWR
	* CKPT

- 实例数据库配置：
	* 非集群系统：单实例 DB
	* 集群系统：RAC DB
	* 实例部署在多个机器上，共享一切（实例读数据时，先看其他实例内存有无，有的话从其他实例内存读），数据库,多实例对应1个数据库；
	* 灾备，双活。

- 11G Grid Infrostructorp 网格基础设施，
	* 包含ASM 自动存储管理,软件实现阵列。数据库进程与ASM进程交互，跳过了操作系统代理。自动数据条带。

下午：
1. oracle linux 
2. 构造一些磁盘，安装GI-ASM
3. 安装RDBMS-DATABASE

步骤： 
1. RDBMS delete;oracle用户 dbca
2. ASM delete;grid用户 asmca
3. 创建新盘。
## HA High Availihty
- 解决
- ORACLE 自身不带高可用，带负载均衡。通过GI的：
	- cluster 实例高可用
	- ASM 存储高可用
一台服务器不能并存两个实例，除非是RAC，ASM在stand alone运行模式下，ASM实例可以和数据库实例并存的。还可以保护数据库
```
oracleasm config -i
oracleasm init
oracleasm createdisk ASMDISK01 /dev/svdh           -09
oralceasm listdisks
ls /dev/oracleasm/disks/
建集群脚本
cat /etc/oratab
grid asmca
oracle用户
dbca (OLTP联机交易，并发巨大，数据处理基于时间点到替换操作；OLAF联机分析,并发巨小，基于时间范围内，所有数据密集运算；BATCH批处理，有时联机交易，有时联机分析)；全局数据库名，域名，用于分布式事务区分；配置企业管理器;SGA不能大于内存大小；block size 是操作系统块（一般4K）的倍数；processes，服务器并发数，包括了用户、服务器、守护进程；字符集，数据库字符集,用于存储元数据（对象命名）采用的,选用通用的，方便迁移(char\varchar/long/clob默认采用数据库字符集，nchar/nvarchr/nlone不是，用户数据用)，国家语言字符集,；
ps -aux|grep -i pmon
```
运维要掌握的：
```
cat /etc/oratab
cd /$ORCLE_HOME/install/
cat portlist.ini
cat /etc/oraInst.loc	显示的目录记录了装了那些ORACLE软件
	到那个目录，cat ContentsXML/inventory.xml
```
